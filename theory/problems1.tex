\newcommand{\groupnumber}{1}

\documentclass[11pt]{article}

\usepackage{hometask}
\usepackage{amsfonts}
\usepackage{expdlist}

\begin{document}

\begin{problem}{15}
	\begin{enumerate} \compact
		\item
		Докажите, что в бинарном дереве с $k$ листьями высота составляет $\Omega(\log k)$.

		\item
		Рассмотрим произвольное (корректное) решающее дерево для задачи сортировки $n$ ключей, в котором все листья являются достижимыми.
		Найдите точную нижнюю оценку на \emph{наименьшую} из глубин листьев данного дерева, т.е.
		такую функцию $g(n)$, что в любом подобном дереве наименьшая глубина листа не меньше $g(n)$,
		и одновременно для любого $n$ существует такое дерево, в котором наименьшая глубина листа равна $g(n)$. 
	\end{enumerate}
\end{problem}

\begin{problem}{30}
	Рассмотрим алгоритмическую задачу с конечным множеством входов $\mathcal{I}$ и произвольное вероятностное распределение на нем. Рассмотрим также некоторое конечное семейство $\mathcal{A}$ детерминированных алгоритмов для ее решения
	и вероятностное распределение на нем. Обозначим через $f_A(I)$ время работы алгоритма
	$A$ на входе $I$. 
	
	\begin{enumerate} \compact
		\item
		Докажите неравенство
		$$
			\min_{A \in \mathcal{A}} E_I\left[ f_A(I) \right] \le \max_{I \in \mathcal{I}} E_A\left[ f_A(I) \right],
		$$
		где матожидания взяты относительно соответствующих распределений.
		Сформулируйте данное неравенство в терминах соотношения сложности в среднем и рандомизированной сложности.

		\item
		Докажите в модели решающих деревьев оценку $\Omega(n \log n)$ для сложности произвольного \emph{рандомизированного}
		алгоритма, основанного на сравнении ключей.
	\end{enumerate}
\end{problem}

\begin{problem}{20}
	Предложите реализацию \emph{cтека} на основе (одного) массива, которая поддерживает операции добавления в конец и удаления из конца. Требуется, чтобы \emph{емкость} (количество выделенных ячеек памяти) стека в любой момент времени отличалась от фактического размера не более чем в константу раз, а учетная сложность операций добавления в конец и удаления из конца была константной.
\end{problem}

\begin{problem}{20}
	Предложите реализацию \emph{очереди} на основе (одного) массива, которая поддерживает операции добавления в конец и удаления из начала. Требуется, чтобы емкость очереди в любой момент времени отличалась от фактического размера не более чем в константу раз, а учетная сложность операций добавления в конец и удаления из начала была константной.
\end{problem}

\begin{problem}{25}
	Покажите, как \emph{деамортизировать} операции вставки в конец вектора, т.е. добиться того, чтобы операции добавления в конец и чтения элемента по индексу требовали $O(1)$ времени в \emph{худшем} случае.
	Будем считать, что выделение и освобождение участка памяти произвольного размера требует $O(1)$ времени.
	Совет: по мере добавления новых элементов необходимо параллельно копировать уже имеющийся массив в массив увеличенного размера. Делать это следует с такой скоростью, чтобы в тот момент,
	когда меньший массив окажется заполнен, мы могли за время $O(1)$ выполнить переключение на новый массив.
\end{problem}

\begin{problem}{35}
	Выпишите рекуррентное соотношение для случайной величины $h(n)$, равной глубине рекурсии в алгоритме \textsc{Quick-Sort} для массива из $n$ ключей
	при рандомизированном способе выбора разделяющего элемента. Докажите, что $E[h(n)] = O(\log n)$.
\end{problem}

\end{document}